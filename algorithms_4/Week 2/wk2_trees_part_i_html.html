<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script>
  function BTNode(value) {
  this.val = value;
  this.left = null;
  this.right = null;
  this.add = function(newNode) {
    // if new node is greater than or equal:
    if (newNode.val >= this.val) {
      if (!this.right) {
        this.right = newNode;
      } else {
        this.right.add(newNode); // recursion
      }
    }
    // if new node is less:
    if (newNode.val < this.val) {
      if (!this.left) {
        this.left = newNode;
      } else {
        this.left.add(newNode);
      }
    }

    return this;
  };
}

function BST() {
 this.root = null;
 this.add = function(val) {
  // This function uses another function built into the tree nodes to help us navigate recursively. A more simple version is defined as the method beneath this one.
   let newNode = new BTNode(val), // create new node
    current = this.root;

  if (!current) {
    this.root = newNode;
  } else {
    current.add(newNode);
  }
  // console.log(this);
  return this;
 };
 this.nonrecursiveAdd = function(val) {
   // In this example we'll create an add function that doesn't use recursive pieces:
   let newNode = new BTNode(val), // create new node
    current = this.root;
  
  if (!current) {
    this.root = newNode;
    return this;
  }

  while (current) {
    // If new node is less:
    if (newNode.val >= current.val) {
      if (!current.right) {
        current.right = newNode;
        return this;
      } else {
        current = current.right;
      }
    }
    // If new node is greater than:
    if (newNode.val < current.val) {
      if (!current.left) {
        current.left = newNode;
        return this;
      } else {
        current = current.left;
      }
    }
  }
 };
 this.contains = function(val) {
   let current = this.root;
   if (!this.root) {
     return null; // empty tree
   }
   while(current) {
     if(val === current.val) {
       return true;
     } else {
       if (val >= current.val) {
         if (current.right) {
          if (current.right.val === val) {
            return true;
          } else {
            current = current.right;
          }
         } else {
           return false;
         }
       } else {
         if (current.left) {
           if (current.left.val === val) {
             return true;
           } else {
             current = current.left;
           }
         } else {
           console.log(false);
           return false; // val not found
         }
       }
     }
    }
    return this;
 };
//  this.min = function() {
   
//  };
//  this.max = function() {
   
//  };
}

console.log("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
console.log("$$$$$$$$$         TEST        $$$$$$$$");
console.log("$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
// let's test our add function:
console.log("======== ADD TO TREE ========");
let myTree = new BST();

myTree.add(1);
myTree.add(2);
myTree.add(3);
myTree.add(4);
myTree.add(-1);
myTree.add(0);
console.log(myTree);

// Test our non-recursive method of doing this:
// myTree.nonrecursiveAdd(1);
// myTree.nonrecursiveAdd(2);
// myTree.nonrecursiveAdd(3);
// myTree.nonrecursiveAdd(4);
myTree.nonrecursiveAdd(-2);
console.log(myTree);

console.log("======== CONTAINS ========");
console.log(myTree.contains(0));
  </script>
</head>
<body>
  
</body>
</html>